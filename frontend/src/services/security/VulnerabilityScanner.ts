// ===========================================
// VULNERABILITY SCANNER & ASSESSMENT
// Automated Security Vulnerability Detection
// ===========================================

interface Vulnerability {
  id: string;
  title: string;
  description: string;
  severity: 'low' | 'medium' | 'high' | 'critical';
  category: 'xss' | 'injection' | 'auth' | 'crypto' | 'config' | 'dependency' | 'privacy' | 'compliance';
  cve_id?: string;
  cvss_score?: number;
  affected_components: string[];
  remediation: string;
  references: string[];
  discovered_at: number;
  status: 'open' | 'acknowledged' | 'in_progress' | 'resolved' | 'false_positive';
  risk_score: number;
}

interface ScanResult {
  scan_id: string;
  timestamp: number;
  scan_type: 'full' | 'dependency' | 'configuration' | 'code' | 'runtime';
  duration: number;
  vulnerabilities: Vulnerability[];
  summary: {
    total: number;
    by_severity: Record<string, number>;
    by_category: Record<string, number>;
    new: number;
    resolved: number;
  };
  compliance_status: {
    gdpr: ComplianceCheck;
    hipaa: ComplianceCheck;
    sox: ComplianceCheck;
    pci_dss: ComplianceCheck;
  };
}

interface ComplianceCheck {
  required: boolean;
  compliant: boolean;
  issues: string[];
  recommendations: string[];
  last_assessed: number;
}

interface SecurityPolicy {
  password_requirements: {
    min_length: number;
    require_uppercase: boolean;
    require_lowercase: boolean;
    require_numbers: boolean;
    require_symbols: boolean;
    max_age_days: number;
  };
  session_management: {
    timeout_minutes: number;
    require_https: boolean;
    secure_cookies: boolean;
    same_site: 'strict' | 'lax' | 'none';
  };
  encryption: {
    min_key_size: number;
    allowed_algorithms: string[];
    require_tls: boolean;
    min_tls_version: string;
  };
  access_control: {
    max_failed_attempts: number;
    lockout_duration_minutes: number;
    require_mfa: boolean;
    allowed_ip_ranges?: string[];
  };
}

interface SecurityHeader {
  name: string;
  value: string;
  required: boolean;
  description: string;
  risk_level: 'low' | 'medium' | 'high';
}

export class VulnerabilityScanner {
  private vulnerabilities: Vulnerability[] = [];
  private scanHistory: ScanResult[] = [];
  private securityPolicy: SecurityPolicy;
  private knownCVEs: Map<string, any> = new Map();

  constructor() {
    this.securityPolicy = this.getDefaultSecurityPolicy();
    this.initialize();
  }

  // ===========================================
  // INITIALIZATION
  // ===========================================

  private async initialize(): Promise<void> {
    try {
      await this.loadKnownVulnerabilities();
      console.log('üîç Vulnerability scanner initialized');
    } catch (error) {
      console.error('Failed to initialize vulnerability scanner:', error);
    }
  }

  private async loadKnownVulnerabilities(): Promise<void> {
    // In production, this would load from CVE databases
    const knownVulns = [
      {
        cve: 'CVE-2024-1234',
        description: 'XSS vulnerability in form handling',
        severity: 'high',
        affected_versions: ['*']
      },
      {
        cve: 'CVE-2024-5678',
        description: 'SQL injection in user input validation',
        severity: 'critical',
        affected_versions: ['*']
      }
    ];

    knownVulns.forEach(vuln => {
      this.knownCVEs.set(vuln.cve, vuln);
    });
  }

  private getDefaultSecurityPolicy(): SecurityPolicy {
    return {
      password_requirements: {
        min_length: 12,
        require_uppercase: true,
        require_lowercase: true,
        require_numbers: true,
        require_symbols: true,
        max_age_days: 90
      },
      session_management: {
        timeout_minutes: 30,
        require_https: true,
        secure_cookies: true,
        same_site: 'strict'
      },
      encryption: {
        min_key_size: 256,
        allowed_algorithms: ['AES-256-GCM', 'ChaCha20-Poly1305'],
        require_tls: true,
        min_tls_version: '1.3'
      },
      access_control: {
        max_failed_attempts: 5,
        lockout_duration_minutes: 15,
        require_mfa: true
      }
    };
  }

  // ===========================================
  // VULNERABILITY SCANNING
  // ===========================================

  async performFullScan(): Promise<ScanResult> {
    const scanId = this.generateScanId();
    const startTime = Date.now();
    
    console.log('üîç Starting comprehensive vulnerability scan...');

    const [
      xssVulns,
      injectionVulns,
      authVulns,
      configVulns,
      depVulns,
      cryptoVulns,
      headerVulns,
      privacyVulns
    ] = await Promise.all([
      this.scanForXSS(),
      this.scanForInjection(),
      this.scanAuthentication(),
      this.scanConfiguration(),
      this.scanDependencies(),
      this.scanCryptography(),
      this.scanSecurityHeaders(),
      this.scanPrivacyCompliance()
    ]);

    const allVulnerabilities = [
      ...xssVulns,
      ...injectionVulns,
      ...authVulns,
      ...configVulns,
      ...depVulns,
      ...cryptoVulns,
      ...headerVulns,
      ...privacyVulns
    ];

    const duration = Date.now() - startTime;
    const complianceStatus = await this.assessCompliance();

    const result: ScanResult = {
      scan_id: scanId,
      timestamp: Date.now(),
      scan_type: 'full',
      duration,
      vulnerabilities: allVulnerabilities,
      summary: this.generateScanSummary(allVulnerabilities),
      compliance_status: complianceStatus
    };

    this.scanHistory.push(result);
    this.updateVulnerabilities(allVulnerabilities);

    console.log(`‚úÖ Vulnerability scan completed: ${allVulnerabilities.length} issues found`);
    return result;
  }

  // ===========================================
  // XSS VULNERABILITY SCANNING
  // ===========================================

  private async scanForXSS(): Promise<Vulnerability[]> {
    const vulnerabilities: Vulnerability[] = [];

    // Check for dangerous innerHTML usage
    const scriptElements = document.querySelectorAll('script');
    scriptElements.forEach((script, index) => {
      if (script.innerHTML.includes('innerHTML') && 
          !script.innerHTML.includes('textContent') &&
          !script.innerHTML.includes('sanitize')) {
        
        vulnerabilities.push({
          id: `xss-innerHTML-${index}`,
          title: 'Unsafe innerHTML Usage',
          description: 'Direct innerHTML assignment without sanitization detected',
          severity: 'high',
          category: 'xss',
          affected_components: [`script-${index}`],
          remediation: 'Use textContent or implement proper HTML sanitization',
          references: ['https://owasp.org/www-community/xss-filter-evasion-cheatsheet'],
          discovered_at: Date.now(),
          status: 'open',
          risk_score: 8.5
        });
      }
    });

    // Check for missing CSP headers
    const cspMeta = document.querySelector('meta[http-equiv="Content-Security-Policy"]');
    if (!cspMeta) {
      vulnerabilities.push({
        id: 'xss-no-csp',
        title: 'Missing Content Security Policy',
        description: 'No CSP header or meta tag found, making the application vulnerable to XSS',
        severity: 'medium',
        category: 'xss',
        affected_components: ['application'],
        remediation: 'Implement Content-Security-Policy header with strict policies',
        references: ['https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP'],
        discovered_at: Date.now(),
        status: 'open',
        risk_score: 6.0
      });
    }

    // Check for inline scripts without nonce
    const inlineScripts = document.querySelectorAll('script:not([src])');
    inlineScripts.forEach((script, index) => {
      if (!script.hasAttribute('nonce') && script.innerHTML.trim()) {
        vulnerabilities.push({
          id: `xss-inline-script-${index}`,
          title: 'Inline Script Without Nonce',
          description: 'Inline script found without CSP nonce, potential XSS risk',
          severity: 'medium',
          category: 'xss',
          affected_components: [`inline-script-${index}`],
          remediation: 'Add nonce attribute to inline scripts or move to external files',
          references: ['https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/script-src'],
          discovered_at: Date.now(),
          status: 'open',
          risk_score: 5.5
        });
      }
    });

    return vulnerabilities;
  }

  // ===========================================
  // INJECTION VULNERABILITY SCANNING
  // ===========================================

  private async scanForInjection(): Promise<Vulnerability[]> {
    const vulnerabilities: Vulnerability[] = [];

    // Check for SQL injection patterns in form inputs
    const forms = document.querySelectorAll('form');
    forms.forEach((form, formIndex) => {
      const inputs = form.querySelectorAll('input, textarea');
      inputs.forEach((input, inputIndex) => {
        if (!input.hasAttribute('pattern') && 
            !input.hasAttribute('maxlength') &&
            input.type !== 'hidden') {
          
          vulnerabilities.push({
            id: `injection-unvalidated-input-${formIndex}-${inputIndex}`,
            title: 'Unvalidated User Input',
            description: 'Form input lacks proper validation attributes',
            severity: 'medium',
            category: 'injection',
            affected_components: [`form-${formIndex}-input-${inputIndex}`],
            remediation: 'Add input validation attributes (pattern, maxlength, etc.)',
            references: ['https://owasp.org/www-project-top-ten/2017/A1_2017-Injection'],
            discovered_at: Date.now(),
            status: 'open',
            risk_score: 6.5
          });
        }
      });
    });

    // Check for dynamic eval usage
    if (typeof window !== 'undefined') {
      const originalEval = window.eval;
      let evalUsed = false;
      
      window.eval = function(...args) {
        evalUsed = true;
        return originalEval.apply(this, args);
      };

      if (evalUsed) {
        vulnerabilities.push({
          id: 'injection-eval-usage',
          title: 'Dynamic Code Execution (eval)',
          description: 'Use of eval() function detected, potential code injection risk',
          severity: 'high',
          category: 'injection',
          affected_components: ['application'],
          remediation: 'Replace eval() with safer alternatives like JSON.parse()',
          references: ['https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/eval#never_use_eval!'],
          discovered_at: Date.now(),
          status: 'open',
          risk_score: 8.0
        });
      }
    }

    return vulnerabilities;
  }

  // ===========================================
  // AUTHENTICATION SCANNING
  // ===========================================

  private async scanAuthentication(): Promise<Vulnerability[]> {
    const vulnerabilities: Vulnerability[] = [];

    // Check for weak password fields
    const passwordInputs = document.querySelectorAll('input[type="password"]');
    passwordInputs.forEach((input, index) => {
      const minLength = input.getAttribute('minlength');
      if (!minLength || parseInt(minLength) < this.securityPolicy.password_requirements.min_length) {
        vulnerabilities.push({
          id: `auth-weak-password-${index}`,
          title: 'Weak Password Requirements',
          description: `Password field allows passwords shorter than ${this.securityPolicy.password_requirements.min_length} characters`,
          severity: 'medium',
          category: 'auth',
          affected_components: [`password-input-${index}`],
          remediation: `Enforce minimum password length of ${this.securityPolicy.password_requirements.min_length} characters`,
          references: ['https://owasp.org/www-project-top-ten/2017/A2_2017-Broken_Authentication'],
          discovered_at: Date.now(),
          status: 'open',
          risk_score: 5.0
        });
      }

      // Check for missing autocomplete="new-password"
      if (!input.hasAttribute('autocomplete') || input.getAttribute('autocomplete') !== 'new-password') {
        vulnerabilities.push({
          id: `auth-autocomplete-${index}`,
          title: 'Missing Autocomplete Security',
          description: 'Password field missing proper autocomplete attribute',
          severity: 'low',
          category: 'auth',
          affected_components: [`password-input-${index}`],
          remediation: 'Add autocomplete="new-password" to password fields',
          references: ['https://developer.mozilla.org/en-US/docs/Web/Security/Securing_your_site/Turning_off_form_autocompletion'],
          discovered_at: Date.now(),
          status: 'open',
          risk_score: 3.0
        });
      }
    });

    // Check for missing CSRF protection
    const forms = document.querySelectorAll('form[method="post"], form[method="PUT"], form[method="DELETE"]');
    forms.forEach((form, index) => {
      const csrfToken = form.querySelector('input[name*="csrf"], input[name*="token"]');
      if (!csrfToken) {
        vulnerabilities.push({
          id: `auth-csrf-${index}`,
          title: 'Missing CSRF Protection',
          description: 'Form lacks CSRF token protection',
          severity: 'high',
          category: 'auth',
          affected_components: [`form-${index}`],
          remediation: 'Add CSRF token to all state-changing forms',
          references: ['https://owasp.org/www-community/attacks/csrf'],
          discovered_at: Date.now(),
          status: 'open',
          risk_score: 7.5
        });
      }
    });

    return vulnerabilities;
  }

  // ===========================================
  // CONFIGURATION SCANNING
  // ===========================================

  private async scanConfiguration(): Promise<Vulnerability[]> {
    const vulnerabilities: Vulnerability[] = [];

    // Check for debug mode indicators
    if (typeof window !== 'undefined') {
      const debugPatterns = ['debug', 'development', 'dev-mode', 'console.log'];
      const htmlContent = document.documentElement.innerHTML;
      
      debugPatterns.forEach(pattern => {
        if (htmlContent.includes(pattern)) {
          vulnerabilities.push({
            id: `config-debug-${pattern}`,
            title: 'Debug Information Exposure',
            description: `Debug pattern "${pattern}" found in production code`,
            severity: 'low',
            category: 'config',
            affected_components: ['application'],
            remediation: 'Remove debug code and console statements from production builds',
            references: ['https://owasp.org/www-project-top-ten/2017/A3_2017-Sensitive_Data_Exposure'],
            discovered_at: Date.now(),
            status: 'open',
            risk_score: 2.5
          });
        }
      });
    }

    // Check for insecure protocols
    const links = document.querySelectorAll('a[href^="http:"], script[src^="http:"], link[href^="http:"]');
    if (links.length > 0) {
      vulnerabilities.push({
        id: 'config-insecure-protocol',
        title: 'Insecure HTTP Protocol Usage',
        description: `${links.length} resources loaded over insecure HTTP protocol`,
        severity: 'medium',
        category: 'config',
        affected_components: ['external-resources'],
        remediation: 'Use HTTPS for all external resources',
        references: ['https://developer.mozilla.org/en-US/docs/Web/Security/Mixed_content'],
        discovered_at: Date.now(),
        status: 'open',
        risk_score: 6.0
      });
    }

    return vulnerabilities;
  }

  // ===========================================
  // DEPENDENCY SCANNING
  // ===========================================

  private async scanDependencies(): Promise<Vulnerability[]> {
    const vulnerabilities: Vulnerability[] = [];

    // Check for outdated libraries (simplified version)
    const scripts = document.querySelectorAll('script[src]');
    scripts.forEach((script, index) => {
      const src = script.getAttribute('src') || '';
      
      // Check for common vulnerable library patterns
      const vulnerablePatterns = [
        { pattern: /jquery.*1\.[0-8]/, name: 'jQuery', version: '< 1.9' },
        { pattern: /angular.*1\.[0-5]/, name: 'AngularJS', version: '< 1.6' },
        { pattern: /bootstrap.*[1-2]\./, name: 'Bootstrap', version: '< 3.0' }
      ];

      vulnerablePatterns.forEach(({ pattern, name, version }) => {
        if (pattern.test(src.toLowerCase())) {
          vulnerabilities.push({
            id: `dep-vulnerable-${name.toLowerCase()}-${index}`,
            title: `Vulnerable ${name} Version`,
            description: `Potentially vulnerable ${name} version detected: ${version}`,
            severity: 'medium',
            category: 'dependency',
            affected_components: [src],
            remediation: `Update ${name} to the latest stable version`,
            references: [`https://nvd.nist.gov/`],
            discovered_at: Date.now(),
            status: 'open',
            risk_score: 5.5
          });
        }
      });
    });

    return vulnerabilities;
  }

  // ===========================================
  // CRYPTOGRAPHY SCANNING
  // ===========================================

  private async scanCryptography(): Promise<Vulnerability[]> {
    const vulnerabilities: Vulnerability[] = [];

    // Check for weak random number generation
    if (typeof window !== 'undefined' && 'crypto' in window) {
      // This is a simplified check - in practice you'd analyze actual usage
      const mathRandomUsage = document.documentElement.innerHTML.includes('Math.random()');
      if (mathRandomUsage) {
        vulnerabilities.push({
          id: 'crypto-weak-random',
          title: 'Weak Random Number Generation',
          description: 'Math.random() usage detected, not cryptographically secure',
          severity: 'medium',
          category: 'crypto',
          affected_components: ['application'],
          remediation: 'Use crypto.getRandomValues() for security-sensitive randomness',
          references: ['https://developer.mozilla.org/en-US/docs/Web/API/Crypto/getRandomValues'],
          discovered_at: Date.now(),
          status: 'open',
          risk_score: 5.0
        });
      }
    }

    // Check for insecure storage of sensitive data
    if (typeof localStorage !== 'undefined') {
      const sensitivePatterns = ['password', 'token', 'key', 'secret'];
      sensitivePatterns.forEach(pattern => {
        for (let i = 0; i < localStorage.length; i++) {
          const key = localStorage.key(i);
          if (key && key.toLowerCase().includes(pattern)) {
            vulnerabilities.push({
              id: `crypto-insecure-storage-${pattern}`,
              title: 'Sensitive Data in Local Storage',
              description: `Potentially sensitive data stored in localStorage: ${key}`,
              severity: 'high',
              category: 'crypto',
              affected_components: ['local-storage'],
              remediation: 'Encrypt sensitive data or use secure session storage',
              references: ['https://owasp.org/www-project-top-ten/2017/A3_2017-Sensitive_Data_Exposure'],
              discovered_at: Date.now(),
              status: 'open',
              risk_score: 7.0
            });
            break; // Only report once per pattern
          }
        }
      });
    }

    return vulnerabilities;
  }

  // ===========================================
  // SECURITY HEADERS SCANNING
  // ===========================================

  private async scanSecurityHeaders(): Promise<Vulnerability[]> {
    const vulnerabilities: Vulnerability[] = [];

    const requiredHeaders: SecurityHeader[] = [
      {
        name: 'Content-Security-Policy',
        value: '',
        required: true,
        description: 'Prevents XSS and code injection attacks',
        risk_level: 'high'
      },
      {
        name: 'X-Frame-Options',
        value: 'DENY',
        required: true,
        description: 'Prevents clickjacking attacks',
        risk_level: 'medium'
      },
      {
        name: 'X-Content-Type-Options',
        value: 'nosniff',
        required: true,
        description: 'Prevents MIME type sniffing',
        risk_level: 'low'
      },
      {
        name: 'Referrer-Policy',
        value: 'strict-origin-when-cross-origin',
        required: true,
        description: 'Controls referrer information',
        risk_level: 'low'
      },
      {
        name: 'Permissions-Policy',
        value: '',
        required: true,
        description: 'Controls browser feature permissions',
        risk_level: 'medium'
      }
    ];

    // Check meta tags for security headers
    requiredHeaders.forEach(header => {
      const metaTag = document.querySelector(`meta[http-equiv="${header.name}"]`);
      if (!metaTag && header.required) {
        const severityMap: Record<string, 'low' | 'medium' | 'high'> = {
          'low': 'low',
          'medium': 'medium',
          'high': 'high'
        };

        vulnerabilities.push({
          id: `header-missing-${header.name.toLowerCase().replace(/[^a-z0-9]/g, '-')}`,
          title: `Missing Security Header: ${header.name}`,
          description: `${header.description}. Header not found in meta tags.`,
          severity: severityMap[header.risk_level],
          category: 'config',
          affected_components: ['http-headers'],
          remediation: `Add ${header.name} header with appropriate value: ${header.value}`,
          references: ['https://owasp.org/www-project-secure-headers/'],
          discovered_at: Date.now(),
          status: 'open',
          risk_score: header.risk_level === 'high' ? 7.0 : header.risk_level === 'medium' ? 5.0 : 3.0
        });
      }
    });

    return vulnerabilities;
  }

  // ===========================================
  // PRIVACY & COMPLIANCE SCANNING
  // ===========================================

  private async scanPrivacyCompliance(): Promise<Vulnerability[]> {
    const vulnerabilities: Vulnerability[] = [];

    // Check for missing privacy policy link
    const privacyLink = document.querySelector('a[href*="privacy"], a[href*="Privacy"]');
    if (!privacyLink) {
      vulnerabilities.push({
        id: 'privacy-no-policy-link',
        title: 'Missing Privacy Policy Link',
        description: 'No privacy policy link found on the page',
        severity: 'medium',
        category: 'privacy',
        affected_components: ['application'],
        remediation: 'Add a clear link to your privacy policy',
        references: ['https://gdpr.eu/privacy-notice/'],
        discovered_at: Date.now(),
        status: 'open',
        risk_score: 4.0
      });
    }

    // Check for cookie consent
    const cookieConsent = document.querySelector('[class*="cookie"], [id*="cookie"], [class*="consent"], [id*="consent"]');
    if (!cookieConsent) {
      vulnerabilities.push({
        id: 'privacy-no-cookie-consent',
        title: 'Missing Cookie Consent',
        description: 'No cookie consent mechanism found',
        severity: 'medium',
        category: 'privacy',
        affected_components: ['application'],
        remediation: 'Implement cookie consent banner for GDPR compliance',
        references: ['https://gdpr.eu/cookies/'],
        discovered_at: Date.now(),
        status: 'open',
        risk_score: 5.0
      });
    }

    // Check for tracking scripts without consent
    const trackingScripts = document.querySelectorAll('script[src*="google-analytics"], script[src*="facebook"], script[src*="twitter"]');
    if (trackingScripts.length > 0 && !cookieConsent) {
      vulnerabilities.push({
        id: 'privacy-tracking-without-consent',
        title: 'Tracking Scripts Without Consent',
        description: `${trackingScripts.length} tracking scripts found without proper consent mechanism`,
        severity: 'high',
        category: 'privacy',
        affected_components: ['tracking-scripts'],
        remediation: 'Implement consent management before loading tracking scripts',
        references: ['https://gdpr.eu/what-is-gdpr/'],
        discovered_at: Date.now(),
        status: 'open',
        risk_score: 6.5
      });
    }

    return vulnerabilities;
  }

  // ===========================================
  // COMPLIANCE ASSESSMENT
  // ===========================================

  private async assessCompliance(): Promise<ScanResult['compliance_status']> {
    return {
      gdpr: await this.assessGDPRCompliance(),
      hipaa: await this.assessHIPAACompliance(),
      sox: await this.assessSOXCompliance(),
      pci_dss: await this.assessPCIDSSCompliance()
    };
  }

  private async assessGDPRCompliance(): Promise<ComplianceCheck> {
    const issues: string[] = [];
    const recommendations: string[] = [];

    // Check for privacy policy
    const privacyLink = document.querySelector('a[href*="privacy"]');
    if (!privacyLink) {
      issues.push('Missing privacy policy link');
      recommendations.push('Add visible privacy policy link');
    }

    // Check for cookie consent
    const cookieConsent = document.querySelector('[class*="cookie"]');
    if (!cookieConsent) {
      issues.push('Missing cookie consent mechanism');
      recommendations.push('Implement GDPR-compliant cookie consent banner');
    }

    // Check for data retention policy
    const dataRetention = document.documentElement.innerHTML.includes('retention');
    if (!dataRetention) {
      issues.push('No data retention policy mentioned');
      recommendations.push('Document and display data retention policies');
    }

    return {
      required: this.securityPolicy ? true : false,
      compliant: issues.length === 0,
      issues,
      recommendations,
      last_assessed: Date.now()
    };
  }

  private async assessHIPAACompliance(): Promise<ComplianceCheck> {
    const issues: string[] = [];
    const recommendations: string[] = [];

    // Check for encryption
    if (location.protocol !== 'https:') {
      issues.push('Non-HTTPS connection detected');
      recommendations.push('Enforce HTTPS for all connections');
    }

    // Check for access controls
    const loginForm = document.querySelector('form input[type="password"]');
    if (!loginForm) {
      issues.push('No authentication mechanism found');
      recommendations.push('Implement user authentication system');
    }

    return {
      required: this.securityPolicy ? false : false, // Would be configurable
      compliant: issues.length === 0,
      issues,
      recommendations,
      last_assessed: Date.now()
    };
  }

  private async assessSOXCompliance(): Promise<ComplianceCheck> {
    return {
      required: false,
      compliant: true,
      issues: [],
      recommendations: [],
      last_assessed: Date.now()
    };
  }

  private async assessPCIDSSCompliance(): Promise<ComplianceCheck> {
    const issues: string[] = [];
    const recommendations: string[] = [];

    // Check for secure transmission
    if (location.protocol !== 'https:') {
      issues.push('Non-HTTPS connection for payment processing');
      recommendations.push('Use HTTPS for all payment-related operations');
    }

    // Check for credit card form security
    const cardInputs = document.querySelectorAll('input[type="text"][placeholder*="card"], input[name*="card"]');
    cardInputs.forEach((input, index) => {
      if (!input.hasAttribute('autocomplete') || 
          input.getAttribute('autocomplete') !== 'cc-number') {
        issues.push(`Credit card input ${index + 1} missing proper autocomplete`);
        recommendations.push('Add proper autocomplete attributes to payment fields');
      }
    });

    return {
      required: false, // Would be determined by presence of payment processing
      compliant: issues.length === 0,
      issues,
      recommendations,
      last_assessed: Date.now()
    };
  }

  // ===========================================
  // UTILITY METHODS
  // ===========================================

  private generateScanId(): string {
    return `scan_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }

  private generateScanSummary(vulnerabilities: Vulnerability[]): ScanResult['summary'] {
    const bySeverity: Record<string, number> = {};
    const byCategory: Record<string, number> = {};

    vulnerabilities.forEach(vuln => {
      bySeverity[vuln.severity] = (bySeverity[vuln.severity] || 0) + 1;
      byCategory[vuln.category] = (byCategory[vuln.category] || 0) + 1;
    });

    return {
      total: vulnerabilities.length,
      by_severity: bySeverity,
      by_category: byCategory,
      new: vulnerabilities.filter(v => v.status === 'open').length,
      resolved: vulnerabilities.filter(v => v.status === 'resolved').length
    };
  }

  private updateVulnerabilities(newVulnerabilities: Vulnerability[]): void {
    // Merge with existing vulnerabilities, avoiding duplicates
    const existingIds = new Set(this.vulnerabilities.map(v => v.id));
    const uniqueNew = newVulnerabilities.filter(v => !existingIds.has(v.id));
    this.vulnerabilities.push(...uniqueNew);
  }

  // ===========================================
  // PUBLIC API
  // ===========================================

  async scanDependencies(): Promise<ScanResult> {
    const scanId = this.generateScanId();
    const startTime = Date.now();
    
    const vulnerabilities = await this.scanDependencies();
    const duration = Date.now() - startTime;

    return {
      scan_id: scanId,
      timestamp: Date.now(),
      scan_type: 'dependency',
      duration,
      vulnerabilities,
      summary: this.generateScanSummary(vulnerabilities),
      compliance_status: await this.assessCompliance()
    };
  }

  getVulnerabilities(filters?: {
    severity?: string;
    category?: string;
    status?: string;
  }): Vulnerability[] {
    let filtered = [...this.vulnerabilities];

    if (filters?.severity) {
      filtered = filtered.filter(v => v.severity === filters.severity);
    }
    if (filters?.category) {
      filtered = filtered.filter(v => v.category === filters.category);
    }
    if (filters?.status) {
      filtered = filtered.filter(v => v.status === filters.status);
    }

    return filtered.sort((a, b) => b.risk_score - a.risk_score);
  }

  updateVulnerabilityStatus(id: string, status: Vulnerability['status']): boolean {
    const vulnerability = this.vulnerabilities.find(v => v.id === id);
    if (!vulnerability) return false;

    vulnerability.status = status;
    return true;
  }

  getScanHistory(): ScanResult[] {
    return [...this.scanHistory].sort((a, b) => b.timestamp - a.timestamp);
  }

  updateSecurityPolicy(policy: Partial<SecurityPolicy>): void {
    this.securityPolicy = { ...this.securityPolicy, ...policy };
  }

  exportVulnerabilityReport(): any {
    return {
      vulnerabilities: this.vulnerabilities,
      scan_history: this.scanHistory,
      policy: this.securityPolicy,
      export_timestamp: Date.now()
    };
  }

  async generateComplianceReport(standard: 'gdpr' | 'hipaa' | 'sox' | 'pci_dss'): Promise<any> {
    const compliance = await this.assessCompliance();
    const selectedCompliance = compliance[standard];
    
    return {
      standard: standard.toUpperCase(),
      compliant: selectedCompliance.compliant,
      issues: selectedCompliance.issues,
      recommendations: selectedCompliance.recommendations,
      related_vulnerabilities: this.vulnerabilities.filter(v => 
        v.category === 'privacy' || v.category === 'compliance'
      ),
      assessment_date: new Date(selectedCompliance.last_assessed).toISOString(),
      next_assessment: new Date(selectedCompliance.last_assessed + 90 * 24 * 60 * 60 * 1000).toISOString()
    };
  }
}

// Export singleton instance
export const vulnerabilityScanner = new VulnerabilityScanner();

export type {
  Vulnerability,
  ScanResult,
  ComplianceCheck,
  SecurityPolicy,
  SecurityHeader
};